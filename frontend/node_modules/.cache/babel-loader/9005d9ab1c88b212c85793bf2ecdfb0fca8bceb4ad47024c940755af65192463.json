{"ast":null,"code":"import React from 'react';\nimport { tree as d3tree, hierarchy } from 'd3-hierarchy';\nimport { select } from 'd3-selection';\nimport { zoom as d3zoom, zoomIdentity } from 'd3-zoom';\nimport { dequal as deepEqual } from 'dequal/lite';\nimport clone from 'clone';\nimport { v4 as uuidv4 } from 'uuid';\nimport TransitionGroupWrapper from './TransitionGroupWrapper.js';\nimport Node from '../Node/index.js';\nimport Link from '../Link/index.js';\nimport globalCss from '../globalCss.js';\nclass Tree extends React.Component {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      dataRef: this.props.data,\n      data: Tree.assignInternalProperties(clone(this.props.data)),\n      d3: Tree.calculateD3Geometry(this.props),\n      isTransitioning: false,\n      isInitialRenderForDataset: true,\n      dataKey: this.props.dataKey\n    };\n    this.internalState = {\n      targetNode: null,\n      isTransitioning: false\n    };\n    this.svgInstanceRef = `rd3t-svg-${uuidv4()}`;\n    this.gInstanceRef = `rd3t-g-${uuidv4()}`;\n    /**\n     * Finds the node matching `nodeId` and\n     * expands/collapses it, depending on the current state of\n     * its internal `collapsed` property.\n     * `setState` callback receives targetNode and handles\n     * `props.onClick` if defined.\n     */\n    this.handleNodeToggle = nodeId => {\n      const data = clone(this.state.data);\n      const matches = this.findNodesById(nodeId, data, []);\n      const targetNodeDatum = matches[0];\n      if (this.props.collapsible && !this.state.isTransitioning) {\n        if (targetNodeDatum.__rd3t.collapsed) {\n          Tree.expandNode(targetNodeDatum);\n          this.props.shouldCollapseNeighborNodes && this.collapseNeighborNodes(targetNodeDatum, data);\n        } else {\n          Tree.collapseNode(targetNodeDatum);\n        }\n        if (this.props.enableLegacyTransitions) {\n          // Lock node toggling while transition takes place.\n          this.setState({\n            data,\n            isTransitioning: true\n          });\n          // Await transitionDuration + 10 ms before unlocking node toggling again.\n          setTimeout(() => this.setState({\n            isTransitioning: false\n          }), this.props.transitionDuration + 10);\n        } else {\n          this.setState({\n            data\n          });\n        }\n        this.internalState.targetNode = targetNodeDatum;\n      }\n    };\n    this.handleAddChildrenToNode = (nodeId, childrenData) => {\n      const data = clone(this.state.data);\n      const matches = this.findNodesById(nodeId, data, []);\n      if (matches.length > 0) {\n        const targetNodeDatum = matches[0];\n        const depth = targetNodeDatum.__rd3t.depth;\n        const formattedChildren = clone(childrenData).map(node => Tree.assignInternalProperties([node], depth + 1));\n        targetNodeDatum.children.push(...formattedChildren.flat());\n        this.setState({\n          data\n        });\n      }\n    };\n    /**\n     * Handles the user-defined `onNodeClick` function.\n     */\n    this.handleOnNodeClickCb = (hierarchyPointNode, evt) => {\n      const {\n        onNodeClick\n      } = this.props;\n      if (onNodeClick && typeof onNodeClick === 'function') {\n        // Persist the SyntheticEvent for downstream handling by users.\n        evt.persist();\n        onNodeClick(clone(hierarchyPointNode), evt);\n      }\n    };\n    /**\n     * Handles the user-defined `onLinkClick` function.\n     */\n    this.handleOnLinkClickCb = (linkSource, linkTarget, evt) => {\n      const {\n        onLinkClick\n      } = this.props;\n      if (onLinkClick && typeof onLinkClick === 'function') {\n        // Persist the SyntheticEvent for downstream handling by users.\n        evt.persist();\n        onLinkClick(clone(linkSource), clone(linkTarget), evt);\n      }\n    };\n    /**\n     * Handles the user-defined `onNodeMouseOver` function.\n     */\n    this.handleOnNodeMouseOverCb = (hierarchyPointNode, evt) => {\n      const {\n        onNodeMouseOver\n      } = this.props;\n      if (onNodeMouseOver && typeof onNodeMouseOver === 'function') {\n        // Persist the SyntheticEvent for downstream handling by users.\n        evt.persist();\n        onNodeMouseOver(clone(hierarchyPointNode), evt);\n      }\n    };\n    /**\n     * Handles the user-defined `onLinkMouseOver` function.\n     */\n    this.handleOnLinkMouseOverCb = (linkSource, linkTarget, evt) => {\n      const {\n        onLinkMouseOver\n      } = this.props;\n      if (onLinkMouseOver && typeof onLinkMouseOver === 'function') {\n        // Persist the SyntheticEvent for downstream handling by users.\n        evt.persist();\n        onLinkMouseOver(clone(linkSource), clone(linkTarget), evt);\n      }\n    };\n    /**\n     * Handles the user-defined `onNodeMouseOut` function.\n     */\n    this.handleOnNodeMouseOutCb = (hierarchyPointNode, evt) => {\n      const {\n        onNodeMouseOut\n      } = this.props;\n      if (onNodeMouseOut && typeof onNodeMouseOut === 'function') {\n        // Persist the SyntheticEvent for downstream handling by users.\n        evt.persist();\n        onNodeMouseOut(clone(hierarchyPointNode), evt);\n      }\n    };\n    /**\n     * Handles the user-defined `onLinkMouseOut` function.\n     */\n    this.handleOnLinkMouseOutCb = (linkSource, linkTarget, evt) => {\n      const {\n        onLinkMouseOut\n      } = this.props;\n      if (onLinkMouseOut && typeof onLinkMouseOut === 'function') {\n        // Persist the SyntheticEvent for downstream handling by users.\n        evt.persist();\n        onLinkMouseOut(clone(linkSource), clone(linkTarget), evt);\n      }\n    };\n    /**\n     * Takes a hierarchy point node and centers the node on the screen\n     * if the dimensions parameter is passed to `Tree`.\n     *\n     * This code is adapted from Rob Schmuecker's centerNode method.\n     * Link: http://bl.ocks.org/robschmuecker/7880033\n     */\n    this.centerNode = hierarchyPointNode => {\n      const {\n        dimensions,\n        orientation,\n        zoom,\n        centeringTransitionDuration\n      } = this.props;\n      if (dimensions) {\n        const g = select(`.${this.gInstanceRef}`);\n        const svg = select(`.${this.svgInstanceRef}`);\n        const scale = this.state.d3.scale;\n        let x;\n        let y;\n        // if the orientation is horizontal, calculate the variables inverted (x->y, y->x)\n        if (orientation === 'horizontal') {\n          y = -hierarchyPointNode.x * scale + dimensions.height / 2;\n          x = -hierarchyPointNode.y * scale + dimensions.width / 2;\n        } else {\n          // else, calculate the variables normally (x->x, y->y)\n          x = -hierarchyPointNode.x * scale + dimensions.width / 2;\n          y = -hierarchyPointNode.y * scale + dimensions.height / 2;\n        }\n        //@ts-ignore\n        g.transition().duration(centeringTransitionDuration).attr('transform', 'translate(' + x + ',' + y + ')scale(' + scale + ')');\n        // Sets the viewport to the new center so that it does not jump back to original\n        // coordinates when dragged/zoomed\n        //@ts-ignore\n        svg.call(d3zoom().transform, zoomIdentity.translate(x, y).scale(zoom));\n      }\n    };\n    /**\n     * Determines which additional `className` prop should be passed to the node & returns it.\n     */\n    this.getNodeClassName = (parent, nodeDatum) => {\n      const {\n        rootNodeClassName,\n        branchNodeClassName,\n        leafNodeClassName\n      } = this.props;\n      const hasParent = parent !== null && parent !== undefined;\n      if (hasParent) {\n        return nodeDatum.children ? branchNodeClassName : leafNodeClassName;\n      } else {\n        return rootNodeClassName;\n      }\n    };\n  }\n  static getDerivedStateFromProps(nextProps, prevState) {\n    let derivedState = null;\n    // Clone new data & assign internal properties if `data` object reference changed.\n    // If the dataKey was present but didn't change, then we don't need to re-render the tree\n    const dataKeyChanged = !nextProps.dataKey || prevState.dataKey !== nextProps.dataKey;\n    if (nextProps.data !== prevState.dataRef && dataKeyChanged) {\n      derivedState = {\n        dataRef: nextProps.data,\n        data: Tree.assignInternalProperties(clone(nextProps.data)),\n        isInitialRenderForDataset: true,\n        dataKey: nextProps.dataKey\n      };\n    }\n    const d3 = Tree.calculateD3Geometry(nextProps);\n    if (!deepEqual(d3, prevState.d3)) {\n      derivedState = derivedState || {};\n      derivedState.d3 = d3;\n    }\n    return derivedState;\n  }\n  componentDidMount() {\n    this.bindZoomListener(this.props);\n    this.setState({\n      isInitialRenderForDataset: false\n    });\n  }\n  componentDidUpdate(prevProps) {\n    if (this.props.data !== prevProps.data) {\n      // If last `render` was due to change in dataset -> mark the initial render as done.\n      this.setState({\n        isInitialRenderForDataset: false\n      });\n    }\n    if (!deepEqual(this.props.translate, prevProps.translate) || !deepEqual(this.props.scaleExtent, prevProps.scaleExtent) || this.props.zoomable !== prevProps.zoomable || this.props.draggable !== prevProps.draggable || this.props.zoom !== prevProps.zoom || this.props.enableLegacyTransitions !== prevProps.enableLegacyTransitions) {\n      // If zoom-specific props change -> rebind listener with new values.\n      // Or: rebind zoom listeners to new DOM nodes in case legacy transitions were enabled/disabled.\n      this.bindZoomListener(this.props);\n    }\n    if (typeof this.props.onUpdate === 'function') {\n      this.props.onUpdate({\n        node: this.internalState.targetNode ? clone(this.internalState.targetNode) : null,\n        zoom: this.state.d3.scale,\n        translate: this.state.d3.translate\n      });\n    }\n    // Reset the last target node after we've flushed it to `onUpdate`.\n    this.internalState.targetNode = null;\n  }\n  /**\n   * Collapses all tree nodes with a `depth` larger than `initialDepth`.\n   *\n   * @param {array} nodeSet Array of nodes generated by `generateTree`\n   * @param {number} initialDepth Maximum initial depth the tree should render\n   */\n  setInitialTreeDepth(nodeSet, initialDepth) {\n    nodeSet.forEach(n => {\n      n.data.__rd3t.collapsed = n.depth >= initialDepth;\n    });\n  }\n  /**\n   * bindZoomListener - If `props.zoomable`, binds a listener for\n   * \"zoom\" events to the SVG and sets scaleExtent to min/max\n   * specified in `props.scaleExtent`.\n   */\n  bindZoomListener(props) {\n    const {\n      zoomable,\n      scaleExtent,\n      translate,\n      zoom,\n      onUpdate,\n      hasInteractiveNodes\n    } = props;\n    const svg = select(`.${this.svgInstanceRef}`);\n    const g = select(`.${this.gInstanceRef}`);\n    // Sets initial offset, so that first pan and zoom does not jump back to default [0,0] coords.\n    // @ts-ignore\n    svg.call(d3zoom().transform, zoomIdentity.translate(translate.x, translate.y).scale(zoom));\n    svg.call(d3zoom().scaleExtent(zoomable ? [scaleExtent.min, scaleExtent.max] : [zoom, zoom])\n    // TODO: break this out into a separate zoom handler fn, rather than inlining it.\n    .filter(event => {\n      if (hasInteractiveNodes) {\n        return event.target.classList.contains(this.svgInstanceRef) || event.target.classList.contains(this.gInstanceRef) || event.shiftKey;\n      }\n      return true;\n    }).on('zoom', event => {\n      if (!this.props.draggable && ['mousemove', 'touchmove', 'dblclick'].includes(event.sourceEvent.type)) {\n        return;\n      }\n      g.attr('transform', event.transform);\n      if (typeof onUpdate === 'function') {\n        // This callback is magically called not only on \"zoom\", but on \"drag\", as well,\n        // even though event.type == \"zoom\".\n        // Taking advantage of this and not writing a \"drag\" handler.\n        onUpdate({\n          node: null,\n          zoom: event.transform.k,\n          translate: {\n            x: event.transform.x,\n            y: event.transform.y\n          }\n        });\n        // TODO: remove this? Shouldn't be mutating state keys directly.\n        this.state.d3.scale = event.transform.k;\n        this.state.d3.translate = {\n          x: event.transform.x,\n          y: event.transform.y\n        };\n      }\n    }));\n  }\n  /**\n   * Assigns internal properties that are required for tree\n   * manipulation to each node in the `data` set and returns a new `data` array.\n   *\n   * @static\n   */\n  static assignInternalProperties(data, currentDepth = 0) {\n    // Wrap the root node into an array for recursive transformations if it wasn't in one already.\n    const d = Array.isArray(data) ? data : [data];\n    return d.map(n => {\n      const nodeDatum = n;\n      nodeDatum.__rd3t = {\n        id: null,\n        depth: null,\n        collapsed: false\n      };\n      nodeDatum.__rd3t.id = uuidv4();\n      // D3@v5 compat: manually assign `depth` to node.data so we don't have\n      // to hold full node+link sets in state.\n      // TODO: avoid this extra step by checking D3's node.depth directly.\n      nodeDatum.__rd3t.depth = currentDepth;\n      // If there are children, recursively assign properties to them too.\n      if (nodeDatum.children && nodeDatum.children.length > 0) {\n        nodeDatum.children = Tree.assignInternalProperties(nodeDatum.children, currentDepth + 1);\n      }\n      return nodeDatum;\n    });\n  }\n  /**\n   * Recursively walks the nested `nodeSet` until a node matching `nodeId` is found.\n   */\n  findNodesById(nodeId, nodeSet, hits) {\n    if (hits.length > 0) {\n      return hits;\n    }\n    hits = hits.concat(nodeSet.filter(node => node.__rd3t.id === nodeId));\n    nodeSet.forEach(node => {\n      if (node.children && node.children.length > 0) {\n        hits = this.findNodesById(nodeId, node.children, hits);\n      }\n    });\n    return hits;\n  }\n  /**\n   * Recursively walks the nested `nodeSet` until all nodes at `depth` have been found.\n   *\n   * @param {number} depth Target depth for which nodes should be returned\n   * @param {array} nodeSet Array of nested `node` objects\n   * @param {array} accumulator Accumulator for matches, passed between recursive calls\n   */\n  findNodesAtDepth(depth, nodeSet, accumulator) {\n    accumulator = accumulator.concat(nodeSet.filter(node => node.__rd3t.depth === depth));\n    nodeSet.forEach(node => {\n      if (node.children && node.children.length > 0) {\n        accumulator = this.findNodesAtDepth(depth, node.children, accumulator);\n      }\n    });\n    return accumulator;\n  }\n  /**\n   * Recursively sets the internal `collapsed` property of\n   * the passed `TreeNodeDatum` and its children to `true`.\n   *\n   * @static\n   */\n  static collapseNode(nodeDatum) {\n    nodeDatum.__rd3t.collapsed = true;\n    if (nodeDatum.children && nodeDatum.children.length > 0) {\n      nodeDatum.children.forEach(child => {\n        Tree.collapseNode(child);\n      });\n    }\n  }\n  /**\n   * Sets the internal `collapsed` property of\n   * the passed `TreeNodeDatum` object to `false`.\n   *\n   * @static\n   */\n  static expandNode(nodeDatum) {\n    nodeDatum.__rd3t.collapsed = false;\n  }\n  /**\n   * Collapses all nodes in `nodeSet` that are neighbors (same depth) of `targetNode`.\n   */\n  collapseNeighborNodes(targetNode, nodeSet) {\n    const neighbors = this.findNodesAtDepth(targetNode.__rd3t.depth, nodeSet, []).filter(node => node.__rd3t.id !== targetNode.__rd3t.id);\n    neighbors.forEach(neighbor => Tree.collapseNode(neighbor));\n  }\n  /**\n   * Generates tree elements (`nodes` and `links`) by\n   * grabbing the rootNode from `this.state.data[0]`.\n   * Restricts tree depth to `props.initialDepth` if defined and if this is\n   * the initial render of the tree.\n   */\n  generateTree() {\n    const {\n      initialDepth,\n      depthFactor,\n      separation,\n      nodeSize,\n      orientation\n    } = this.props;\n    const {\n      isInitialRenderForDataset\n    } = this.state;\n    const tree = d3tree().nodeSize(orientation === 'horizontal' ? [nodeSize.y, nodeSize.x] : [nodeSize.x, nodeSize.y]).separation((a, b) => a.parent.data.__rd3t.id === b.parent.data.__rd3t.id ? separation.siblings : separation.nonSiblings);\n    const rootNode = tree(hierarchy(this.state.data[0], d => d.__rd3t.collapsed ? null : d.children));\n    let nodes = rootNode.descendants();\n    const links = rootNode.links();\n    // Configure nodes' `collapsed` property on first render if `initialDepth` is defined.\n    if (initialDepth !== undefined && isInitialRenderForDataset) {\n      this.setInitialTreeDepth(nodes, initialDepth);\n    }\n    if (depthFactor) {\n      nodes.forEach(node => {\n        node.y = node.depth * depthFactor;\n      });\n    }\n    return {\n      nodes,\n      links\n    };\n  }\n  /**\n   * Set initial zoom and position.\n   * Also limit zoom level according to `scaleExtent` on initial display. This is necessary,\n   * because the first time we are setting it as an SVG property, instead of going\n   * through D3's scaling mechanism, which would have picked up both properties.\n   *\n   * @static\n   */\n  static calculateD3Geometry(nextProps) {\n    let scale;\n    if (nextProps.zoom > nextProps.scaleExtent.max) {\n      scale = nextProps.scaleExtent.max;\n    } else if (nextProps.zoom < nextProps.scaleExtent.min) {\n      scale = nextProps.scaleExtent.min;\n    } else {\n      scale = nextProps.zoom;\n    }\n    return {\n      translate: nextProps.translate,\n      scale\n    };\n  }\n  render() {\n    const {\n      nodes,\n      links\n    } = this.generateTree();\n    const {\n      renderCustomNodeElement,\n      orientation,\n      pathFunc,\n      transitionDuration,\n      nodeSize,\n      depthFactor,\n      initialDepth,\n      separation,\n      enableLegacyTransitions,\n      svgClassName,\n      pathClassFunc\n    } = this.props;\n    const {\n      translate,\n      scale\n    } = this.state.d3;\n    const subscriptions = Object.assign(Object.assign(Object.assign({}, nodeSize), separation), {\n      depthFactor,\n      initialDepth\n    });\n    return React.createElement(\"div\", {\n      className: \"rd3t-tree-container rd3t-grabbable\"\n    }, React.createElement(\"style\", null, globalCss), React.createElement(\"svg\", {\n      className: `rd3t-svg ${this.svgInstanceRef} ${svgClassName}`,\n      width: \"100%\",\n      height: \"100%\"\n    }, React.createElement(TransitionGroupWrapper, {\n      enableLegacyTransitions: enableLegacyTransitions,\n      component: \"g\",\n      className: `rd3t-g ${this.gInstanceRef}`,\n      transform: `translate(${translate.x},${translate.y}) scale(${scale})`\n    }, links.map((linkData, i) => {\n      return React.createElement(Link, {\n        key: 'link-' + i,\n        orientation: orientation,\n        pathFunc: pathFunc,\n        pathClassFunc: pathClassFunc,\n        linkData: linkData,\n        onClick: this.handleOnLinkClickCb,\n        onMouseOver: this.handleOnLinkMouseOverCb,\n        onMouseOut: this.handleOnLinkMouseOutCb,\n        enableLegacyTransitions: enableLegacyTransitions,\n        transitionDuration: transitionDuration\n      });\n    }), nodes.map((hierarchyPointNode, i) => {\n      const {\n        data,\n        x,\n        y,\n        parent\n      } = hierarchyPointNode;\n      return React.createElement(Node, {\n        key: 'node-' + i,\n        data: data,\n        position: {\n          x,\n          y\n        },\n        hierarchyPointNode: hierarchyPointNode,\n        parent: parent,\n        nodeClassName: this.getNodeClassName(parent, data),\n        renderCustomNodeElement: renderCustomNodeElement,\n        nodeSize: nodeSize,\n        orientation: orientation,\n        enableLegacyTransitions: enableLegacyTransitions,\n        transitionDuration: transitionDuration,\n        onNodeToggle: this.handleNodeToggle,\n        onNodeClick: this.handleOnNodeClickCb,\n        onNodeMouseOver: this.handleOnNodeMouseOverCb,\n        onNodeMouseOut: this.handleOnNodeMouseOutCb,\n        handleAddChildrenToNode: this.handleAddChildrenToNode,\n        subscriptions: subscriptions,\n        centerNode: this.centerNode\n      });\n    }))));\n  }\n}\nTree.defaultProps = {\n  onNodeClick: undefined,\n  onNodeMouseOver: undefined,\n  onNodeMouseOut: undefined,\n  onLinkClick: undefined,\n  onLinkMouseOver: undefined,\n  onLinkMouseOut: undefined,\n  onUpdate: undefined,\n  orientation: 'horizontal',\n  translate: {\n    x: 0,\n    y: 0\n  },\n  pathFunc: 'diagonal',\n  pathClassFunc: undefined,\n  transitionDuration: 500,\n  depthFactor: undefined,\n  collapsible: true,\n  initialDepth: undefined,\n  zoomable: true,\n  draggable: true,\n  zoom: 1,\n  scaleExtent: {\n    min: 0.1,\n    max: 1\n  },\n  nodeSize: {\n    x: 140,\n    y: 140\n  },\n  separation: {\n    siblings: 1,\n    nonSiblings: 2\n  },\n  shouldCollapseNeighborNodes: false,\n  svgClassName: '',\n  rootNodeClassName: '',\n  branchNodeClassName: '',\n  leafNodeClassName: '',\n  renderCustomNodeElement: undefined,\n  enableLegacyTransitions: false,\n  hasInteractiveNodes: false,\n  dimensions: undefined,\n  centeringTransitionDuration: 800,\n  dataKey: undefined\n};\nexport default Tree;","map":{"version":3,"names":["React","tree","d3tree","hierarchy","select","zoom","d3zoom","zoomIdentity","dequal","deepEqual","clone","v4","uuidv4","TransitionGroupWrapper","Node","Link","globalCss","Tree","Component","constructor","arguments","state","dataRef","props","data","assignInternalProperties","d3","calculateD3Geometry","isTransitioning","isInitialRenderForDataset","dataKey","internalState","targetNode","svgInstanceRef","gInstanceRef","handleNodeToggle","nodeId","matches","findNodesById","targetNodeDatum","collapsible","__rd3t","collapsed","expandNode","shouldCollapseNeighborNodes","collapseNeighborNodes","collapseNode","enableLegacyTransitions","setState","setTimeout","transitionDuration","handleAddChildrenToNode","childrenData","length","depth","formattedChildren","map","node","children","push","flat","handleOnNodeClickCb","hierarchyPointNode","evt","onNodeClick","persist","handleOnLinkClickCb","linkSource","linkTarget","onLinkClick","handleOnNodeMouseOverCb","onNodeMouseOver","handleOnLinkMouseOverCb","onLinkMouseOver","handleOnNodeMouseOutCb","onNodeMouseOut","handleOnLinkMouseOutCb","onLinkMouseOut","centerNode","dimensions","orientation","centeringTransitionDuration","g","svg","scale","x","y","height","width","transition","duration","attr","call","transform","translate","getNodeClassName","parent","nodeDatum","rootNodeClassName","branchNodeClassName","leafNodeClassName","hasParent","undefined","getDerivedStateFromProps","nextProps","prevState","derivedState","dataKeyChanged","componentDidMount","bindZoomListener","componentDidUpdate","prevProps","scaleExtent","zoomable","draggable","onUpdate","setInitialTreeDepth","nodeSet","initialDepth","forEach","n","hasInteractiveNodes","min","max","filter","event","target","classList","contains","shiftKey","on","includes","sourceEvent","type","k","currentDepth","d","Array","isArray","id","hits","concat","findNodesAtDepth","accumulator","child","neighbors","neighbor","generateTree","depthFactor","separation","nodeSize","a","b","siblings","nonSiblings","rootNode","nodes","descendants","links","render","renderCustomNodeElement","pathFunc","svgClassName","pathClassFunc","subscriptions","Object","assign","createElement","className","component","linkData","i","key","onClick","onMouseOver","onMouseOut","position","nodeClassName","onNodeToggle","defaultProps"],"sources":["/Users/ayushi/Desktop/repos/nexpert-frontend/node_modules/react-d3-tree/lib/esm/Tree/index.js"],"sourcesContent":["import React from 'react';\nimport { tree as d3tree, hierarchy } from 'd3-hierarchy';\nimport { select } from 'd3-selection';\nimport { zoom as d3zoom, zoomIdentity } from 'd3-zoom';\nimport { dequal as deepEqual } from 'dequal/lite';\nimport clone from 'clone';\nimport { v4 as uuidv4 } from 'uuid';\nimport TransitionGroupWrapper from './TransitionGroupWrapper.js';\nimport Node from '../Node/index.js';\nimport Link from '../Link/index.js';\nimport globalCss from '../globalCss.js';\nclass Tree extends React.Component {\n    constructor() {\n        super(...arguments);\n        this.state = {\n            dataRef: this.props.data,\n            data: Tree.assignInternalProperties(clone(this.props.data)),\n            d3: Tree.calculateD3Geometry(this.props),\n            isTransitioning: false,\n            isInitialRenderForDataset: true,\n            dataKey: this.props.dataKey,\n        };\n        this.internalState = {\n            targetNode: null,\n            isTransitioning: false,\n        };\n        this.svgInstanceRef = `rd3t-svg-${uuidv4()}`;\n        this.gInstanceRef = `rd3t-g-${uuidv4()}`;\n        /**\n         * Finds the node matching `nodeId` and\n         * expands/collapses it, depending on the current state of\n         * its internal `collapsed` property.\n         * `setState` callback receives targetNode and handles\n         * `props.onClick` if defined.\n         */\n        this.handleNodeToggle = (nodeId) => {\n            const data = clone(this.state.data);\n            const matches = this.findNodesById(nodeId, data, []);\n            const targetNodeDatum = matches[0];\n            if (this.props.collapsible && !this.state.isTransitioning) {\n                if (targetNodeDatum.__rd3t.collapsed) {\n                    Tree.expandNode(targetNodeDatum);\n                    this.props.shouldCollapseNeighborNodes && this.collapseNeighborNodes(targetNodeDatum, data);\n                }\n                else {\n                    Tree.collapseNode(targetNodeDatum);\n                }\n                if (this.props.enableLegacyTransitions) {\n                    // Lock node toggling while transition takes place.\n                    this.setState({ data, isTransitioning: true });\n                    // Await transitionDuration + 10 ms before unlocking node toggling again.\n                    setTimeout(() => this.setState({ isTransitioning: false }), this.props.transitionDuration + 10);\n                }\n                else {\n                    this.setState({ data });\n                }\n                this.internalState.targetNode = targetNodeDatum;\n            }\n        };\n        this.handleAddChildrenToNode = (nodeId, childrenData) => {\n            const data = clone(this.state.data);\n            const matches = this.findNodesById(nodeId, data, []);\n            if (matches.length > 0) {\n                const targetNodeDatum = matches[0];\n                const depth = targetNodeDatum.__rd3t.depth;\n                const formattedChildren = clone(childrenData).map((node) => Tree.assignInternalProperties([node], depth + 1));\n                targetNodeDatum.children.push(...formattedChildren.flat());\n                this.setState({ data });\n            }\n        };\n        /**\n         * Handles the user-defined `onNodeClick` function.\n         */\n        this.handleOnNodeClickCb = (hierarchyPointNode, evt) => {\n            const { onNodeClick } = this.props;\n            if (onNodeClick && typeof onNodeClick === 'function') {\n                // Persist the SyntheticEvent for downstream handling by users.\n                evt.persist();\n                onNodeClick(clone(hierarchyPointNode), evt);\n            }\n        };\n        /**\n         * Handles the user-defined `onLinkClick` function.\n         */\n        this.handleOnLinkClickCb = (linkSource, linkTarget, evt) => {\n            const { onLinkClick } = this.props;\n            if (onLinkClick && typeof onLinkClick === 'function') {\n                // Persist the SyntheticEvent for downstream handling by users.\n                evt.persist();\n                onLinkClick(clone(linkSource), clone(linkTarget), evt);\n            }\n        };\n        /**\n         * Handles the user-defined `onNodeMouseOver` function.\n         */\n        this.handleOnNodeMouseOverCb = (hierarchyPointNode, evt) => {\n            const { onNodeMouseOver } = this.props;\n            if (onNodeMouseOver && typeof onNodeMouseOver === 'function') {\n                // Persist the SyntheticEvent for downstream handling by users.\n                evt.persist();\n                onNodeMouseOver(clone(hierarchyPointNode), evt);\n            }\n        };\n        /**\n         * Handles the user-defined `onLinkMouseOver` function.\n         */\n        this.handleOnLinkMouseOverCb = (linkSource, linkTarget, evt) => {\n            const { onLinkMouseOver } = this.props;\n            if (onLinkMouseOver && typeof onLinkMouseOver === 'function') {\n                // Persist the SyntheticEvent for downstream handling by users.\n                evt.persist();\n                onLinkMouseOver(clone(linkSource), clone(linkTarget), evt);\n            }\n        };\n        /**\n         * Handles the user-defined `onNodeMouseOut` function.\n         */\n        this.handleOnNodeMouseOutCb = (hierarchyPointNode, evt) => {\n            const { onNodeMouseOut } = this.props;\n            if (onNodeMouseOut && typeof onNodeMouseOut === 'function') {\n                // Persist the SyntheticEvent for downstream handling by users.\n                evt.persist();\n                onNodeMouseOut(clone(hierarchyPointNode), evt);\n            }\n        };\n        /**\n         * Handles the user-defined `onLinkMouseOut` function.\n         */\n        this.handleOnLinkMouseOutCb = (linkSource, linkTarget, evt) => {\n            const { onLinkMouseOut } = this.props;\n            if (onLinkMouseOut && typeof onLinkMouseOut === 'function') {\n                // Persist the SyntheticEvent for downstream handling by users.\n                evt.persist();\n                onLinkMouseOut(clone(linkSource), clone(linkTarget), evt);\n            }\n        };\n        /**\n         * Takes a hierarchy point node and centers the node on the screen\n         * if the dimensions parameter is passed to `Tree`.\n         *\n         * This code is adapted from Rob Schmuecker's centerNode method.\n         * Link: http://bl.ocks.org/robschmuecker/7880033\n         */\n        this.centerNode = (hierarchyPointNode) => {\n            const { dimensions, orientation, zoom, centeringTransitionDuration } = this.props;\n            if (dimensions) {\n                const g = select(`.${this.gInstanceRef}`);\n                const svg = select(`.${this.svgInstanceRef}`);\n                const scale = this.state.d3.scale;\n                let x;\n                let y;\n                // if the orientation is horizontal, calculate the variables inverted (x->y, y->x)\n                if (orientation === 'horizontal') {\n                    y = -hierarchyPointNode.x * scale + dimensions.height / 2;\n                    x = -hierarchyPointNode.y * scale + dimensions.width / 2;\n                }\n                else {\n                    // else, calculate the variables normally (x->x, y->y)\n                    x = -hierarchyPointNode.x * scale + dimensions.width / 2;\n                    y = -hierarchyPointNode.y * scale + dimensions.height / 2;\n                }\n                //@ts-ignore\n                g.transition()\n                    .duration(centeringTransitionDuration)\n                    .attr('transform', 'translate(' + x + ',' + y + ')scale(' + scale + ')');\n                // Sets the viewport to the new center so that it does not jump back to original\n                // coordinates when dragged/zoomed\n                //@ts-ignore\n                svg.call(d3zoom().transform, zoomIdentity.translate(x, y).scale(zoom));\n            }\n        };\n        /**\n         * Determines which additional `className` prop should be passed to the node & returns it.\n         */\n        this.getNodeClassName = (parent, nodeDatum) => {\n            const { rootNodeClassName, branchNodeClassName, leafNodeClassName } = this.props;\n            const hasParent = parent !== null && parent !== undefined;\n            if (hasParent) {\n                return nodeDatum.children ? branchNodeClassName : leafNodeClassName;\n            }\n            else {\n                return rootNodeClassName;\n            }\n        };\n    }\n    static getDerivedStateFromProps(nextProps, prevState) {\n        let derivedState = null;\n        // Clone new data & assign internal properties if `data` object reference changed.\n        // If the dataKey was present but didn't change, then we don't need to re-render the tree\n        const dataKeyChanged = !nextProps.dataKey || prevState.dataKey !== nextProps.dataKey;\n        if (nextProps.data !== prevState.dataRef && dataKeyChanged) {\n            derivedState = {\n                dataRef: nextProps.data,\n                data: Tree.assignInternalProperties(clone(nextProps.data)),\n                isInitialRenderForDataset: true,\n                dataKey: nextProps.dataKey,\n            };\n        }\n        const d3 = Tree.calculateD3Geometry(nextProps);\n        if (!deepEqual(d3, prevState.d3)) {\n            derivedState = derivedState || {};\n            derivedState.d3 = d3;\n        }\n        return derivedState;\n    }\n    componentDidMount() {\n        this.bindZoomListener(this.props);\n        this.setState({ isInitialRenderForDataset: false });\n    }\n    componentDidUpdate(prevProps) {\n        if (this.props.data !== prevProps.data) {\n            // If last `render` was due to change in dataset -> mark the initial render as done.\n            this.setState({ isInitialRenderForDataset: false });\n        }\n        if (!deepEqual(this.props.translate, prevProps.translate) ||\n            !deepEqual(this.props.scaleExtent, prevProps.scaleExtent) ||\n            this.props.zoomable !== prevProps.zoomable ||\n            this.props.draggable !== prevProps.draggable ||\n            this.props.zoom !== prevProps.zoom ||\n            this.props.enableLegacyTransitions !== prevProps.enableLegacyTransitions) {\n            // If zoom-specific props change -> rebind listener with new values.\n            // Or: rebind zoom listeners to new DOM nodes in case legacy transitions were enabled/disabled.\n            this.bindZoomListener(this.props);\n        }\n        if (typeof this.props.onUpdate === 'function') {\n            this.props.onUpdate({\n                node: this.internalState.targetNode ? clone(this.internalState.targetNode) : null,\n                zoom: this.state.d3.scale,\n                translate: this.state.d3.translate,\n            });\n        }\n        // Reset the last target node after we've flushed it to `onUpdate`.\n        this.internalState.targetNode = null;\n    }\n    /**\n     * Collapses all tree nodes with a `depth` larger than `initialDepth`.\n     *\n     * @param {array} nodeSet Array of nodes generated by `generateTree`\n     * @param {number} initialDepth Maximum initial depth the tree should render\n     */\n    setInitialTreeDepth(nodeSet, initialDepth) {\n        nodeSet.forEach(n => {\n            n.data.__rd3t.collapsed = n.depth >= initialDepth;\n        });\n    }\n    /**\n     * bindZoomListener - If `props.zoomable`, binds a listener for\n     * \"zoom\" events to the SVG and sets scaleExtent to min/max\n     * specified in `props.scaleExtent`.\n     */\n    bindZoomListener(props) {\n        const { zoomable, scaleExtent, translate, zoom, onUpdate, hasInteractiveNodes } = props;\n        const svg = select(`.${this.svgInstanceRef}`);\n        const g = select(`.${this.gInstanceRef}`);\n        // Sets initial offset, so that first pan and zoom does not jump back to default [0,0] coords.\n        // @ts-ignore\n        svg.call(d3zoom().transform, zoomIdentity.translate(translate.x, translate.y).scale(zoom));\n        svg.call(d3zoom()\n            .scaleExtent(zoomable ? [scaleExtent.min, scaleExtent.max] : [zoom, zoom])\n            // TODO: break this out into a separate zoom handler fn, rather than inlining it.\n            .filter((event) => {\n            if (hasInteractiveNodes) {\n                return (event.target.classList.contains(this.svgInstanceRef) ||\n                    event.target.classList.contains(this.gInstanceRef) ||\n                    event.shiftKey);\n            }\n            return true;\n        })\n            .on('zoom', (event) => {\n            if (!this.props.draggable &&\n                ['mousemove', 'touchmove', 'dblclick'].includes(event.sourceEvent.type)) {\n                return;\n            }\n            g.attr('transform', event.transform);\n            if (typeof onUpdate === 'function') {\n                // This callback is magically called not only on \"zoom\", but on \"drag\", as well,\n                // even though event.type == \"zoom\".\n                // Taking advantage of this and not writing a \"drag\" handler.\n                onUpdate({\n                    node: null,\n                    zoom: event.transform.k,\n                    translate: { x: event.transform.x, y: event.transform.y },\n                });\n                // TODO: remove this? Shouldn't be mutating state keys directly.\n                this.state.d3.scale = event.transform.k;\n                this.state.d3.translate = {\n                    x: event.transform.x,\n                    y: event.transform.y,\n                };\n            }\n        }));\n    }\n    /**\n     * Assigns internal properties that are required for tree\n     * manipulation to each node in the `data` set and returns a new `data` array.\n     *\n     * @static\n     */\n    static assignInternalProperties(data, currentDepth = 0) {\n        // Wrap the root node into an array for recursive transformations if it wasn't in one already.\n        const d = Array.isArray(data) ? data : [data];\n        return d.map(n => {\n            const nodeDatum = n;\n            nodeDatum.__rd3t = { id: null, depth: null, collapsed: false };\n            nodeDatum.__rd3t.id = uuidv4();\n            // D3@v5 compat: manually assign `depth` to node.data so we don't have\n            // to hold full node+link sets in state.\n            // TODO: avoid this extra step by checking D3's node.depth directly.\n            nodeDatum.__rd3t.depth = currentDepth;\n            // If there are children, recursively assign properties to them too.\n            if (nodeDatum.children && nodeDatum.children.length > 0) {\n                nodeDatum.children = Tree.assignInternalProperties(nodeDatum.children, currentDepth + 1);\n            }\n            return nodeDatum;\n        });\n    }\n    /**\n     * Recursively walks the nested `nodeSet` until a node matching `nodeId` is found.\n     */\n    findNodesById(nodeId, nodeSet, hits) {\n        if (hits.length > 0) {\n            return hits;\n        }\n        hits = hits.concat(nodeSet.filter(node => node.__rd3t.id === nodeId));\n        nodeSet.forEach(node => {\n            if (node.children && node.children.length > 0) {\n                hits = this.findNodesById(nodeId, node.children, hits);\n            }\n        });\n        return hits;\n    }\n    /**\n     * Recursively walks the nested `nodeSet` until all nodes at `depth` have been found.\n     *\n     * @param {number} depth Target depth for which nodes should be returned\n     * @param {array} nodeSet Array of nested `node` objects\n     * @param {array} accumulator Accumulator for matches, passed between recursive calls\n     */\n    findNodesAtDepth(depth, nodeSet, accumulator) {\n        accumulator = accumulator.concat(nodeSet.filter(node => node.__rd3t.depth === depth));\n        nodeSet.forEach(node => {\n            if (node.children && node.children.length > 0) {\n                accumulator = this.findNodesAtDepth(depth, node.children, accumulator);\n            }\n        });\n        return accumulator;\n    }\n    /**\n     * Recursively sets the internal `collapsed` property of\n     * the passed `TreeNodeDatum` and its children to `true`.\n     *\n     * @static\n     */\n    static collapseNode(nodeDatum) {\n        nodeDatum.__rd3t.collapsed = true;\n        if (nodeDatum.children && nodeDatum.children.length > 0) {\n            nodeDatum.children.forEach(child => {\n                Tree.collapseNode(child);\n            });\n        }\n    }\n    /**\n     * Sets the internal `collapsed` property of\n     * the passed `TreeNodeDatum` object to `false`.\n     *\n     * @static\n     */\n    static expandNode(nodeDatum) {\n        nodeDatum.__rd3t.collapsed = false;\n    }\n    /**\n     * Collapses all nodes in `nodeSet` that are neighbors (same depth) of `targetNode`.\n     */\n    collapseNeighborNodes(targetNode, nodeSet) {\n        const neighbors = this.findNodesAtDepth(targetNode.__rd3t.depth, nodeSet, []).filter(node => node.__rd3t.id !== targetNode.__rd3t.id);\n        neighbors.forEach(neighbor => Tree.collapseNode(neighbor));\n    }\n    /**\n     * Generates tree elements (`nodes` and `links`) by\n     * grabbing the rootNode from `this.state.data[0]`.\n     * Restricts tree depth to `props.initialDepth` if defined and if this is\n     * the initial render of the tree.\n     */\n    generateTree() {\n        const { initialDepth, depthFactor, separation, nodeSize, orientation } = this.props;\n        const { isInitialRenderForDataset } = this.state;\n        const tree = d3tree()\n            .nodeSize(orientation === 'horizontal' ? [nodeSize.y, nodeSize.x] : [nodeSize.x, nodeSize.y])\n            .separation((a, b) => a.parent.data.__rd3t.id === b.parent.data.__rd3t.id\n            ? separation.siblings\n            : separation.nonSiblings);\n        const rootNode = tree(hierarchy(this.state.data[0], d => (d.__rd3t.collapsed ? null : d.children)));\n        let nodes = rootNode.descendants();\n        const links = rootNode.links();\n        // Configure nodes' `collapsed` property on first render if `initialDepth` is defined.\n        if (initialDepth !== undefined && isInitialRenderForDataset) {\n            this.setInitialTreeDepth(nodes, initialDepth);\n        }\n        if (depthFactor) {\n            nodes.forEach(node => {\n                node.y = node.depth * depthFactor;\n            });\n        }\n        return { nodes, links };\n    }\n    /**\n     * Set initial zoom and position.\n     * Also limit zoom level according to `scaleExtent` on initial display. This is necessary,\n     * because the first time we are setting it as an SVG property, instead of going\n     * through D3's scaling mechanism, which would have picked up both properties.\n     *\n     * @static\n     */\n    static calculateD3Geometry(nextProps) {\n        let scale;\n        if (nextProps.zoom > nextProps.scaleExtent.max) {\n            scale = nextProps.scaleExtent.max;\n        }\n        else if (nextProps.zoom < nextProps.scaleExtent.min) {\n            scale = nextProps.scaleExtent.min;\n        }\n        else {\n            scale = nextProps.zoom;\n        }\n        return {\n            translate: nextProps.translate,\n            scale,\n        };\n    }\n    render() {\n        const { nodes, links } = this.generateTree();\n        const { renderCustomNodeElement, orientation, pathFunc, transitionDuration, nodeSize, depthFactor, initialDepth, separation, enableLegacyTransitions, svgClassName, pathClassFunc, } = this.props;\n        const { translate, scale } = this.state.d3;\n        const subscriptions = Object.assign(Object.assign(Object.assign({}, nodeSize), separation), { depthFactor,\n            initialDepth });\n        return (React.createElement(\"div\", { className: \"rd3t-tree-container rd3t-grabbable\" },\n            React.createElement(\"style\", null, globalCss),\n            React.createElement(\"svg\", { className: `rd3t-svg ${this.svgInstanceRef} ${svgClassName}`, width: \"100%\", height: \"100%\" },\n                React.createElement(TransitionGroupWrapper, { enableLegacyTransitions: enableLegacyTransitions, component: \"g\", className: `rd3t-g ${this.gInstanceRef}`, transform: `translate(${translate.x},${translate.y}) scale(${scale})` },\n                    links.map((linkData, i) => {\n                        return (React.createElement(Link, { key: 'link-' + i, orientation: orientation, pathFunc: pathFunc, pathClassFunc: pathClassFunc, linkData: linkData, onClick: this.handleOnLinkClickCb, onMouseOver: this.handleOnLinkMouseOverCb, onMouseOut: this.handleOnLinkMouseOutCb, enableLegacyTransitions: enableLegacyTransitions, transitionDuration: transitionDuration }));\n                    }),\n                    nodes.map((hierarchyPointNode, i) => {\n                        const { data, x, y, parent } = hierarchyPointNode;\n                        return (React.createElement(Node, { key: 'node-' + i, data: data, position: { x, y }, hierarchyPointNode: hierarchyPointNode, parent: parent, nodeClassName: this.getNodeClassName(parent, data), renderCustomNodeElement: renderCustomNodeElement, nodeSize: nodeSize, orientation: orientation, enableLegacyTransitions: enableLegacyTransitions, transitionDuration: transitionDuration, onNodeToggle: this.handleNodeToggle, onNodeClick: this.handleOnNodeClickCb, onNodeMouseOver: this.handleOnNodeMouseOverCb, onNodeMouseOut: this.handleOnNodeMouseOutCb, handleAddChildrenToNode: this.handleAddChildrenToNode, subscriptions: subscriptions, centerNode: this.centerNode }));\n                    })))));\n    }\n}\nTree.defaultProps = {\n    onNodeClick: undefined,\n    onNodeMouseOver: undefined,\n    onNodeMouseOut: undefined,\n    onLinkClick: undefined,\n    onLinkMouseOver: undefined,\n    onLinkMouseOut: undefined,\n    onUpdate: undefined,\n    orientation: 'horizontal',\n    translate: { x: 0, y: 0 },\n    pathFunc: 'diagonal',\n    pathClassFunc: undefined,\n    transitionDuration: 500,\n    depthFactor: undefined,\n    collapsible: true,\n    initialDepth: undefined,\n    zoomable: true,\n    draggable: true,\n    zoom: 1,\n    scaleExtent: { min: 0.1, max: 1 },\n    nodeSize: { x: 140, y: 140 },\n    separation: { siblings: 1, nonSiblings: 2 },\n    shouldCollapseNeighborNodes: false,\n    svgClassName: '',\n    rootNodeClassName: '',\n    branchNodeClassName: '',\n    leafNodeClassName: '',\n    renderCustomNodeElement: undefined,\n    enableLegacyTransitions: false,\n    hasInteractiveNodes: false,\n    dimensions: undefined,\n    centeringTransitionDuration: 800,\n    dataKey: undefined,\n};\nexport default Tree;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
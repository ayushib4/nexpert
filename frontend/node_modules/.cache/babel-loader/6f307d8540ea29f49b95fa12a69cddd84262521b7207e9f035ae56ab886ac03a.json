{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.getChildMapping = getChildMapping;\nexports.mergeChildMappings = mergeChildMappings;\nvar _react = require('react');\n\n/**\n * Given `this.props.children`, return an object mapping key to child.\n *\n * @param {*} children `this.props.children`\n * @return {object} Mapping of key to child\n */\nfunction getChildMapping(children) {\n  if (!children) {\n    return children;\n  }\n  var result = {};\n  _react.Children.map(children, function (child) {\n    return child;\n  }).forEach(function (child) {\n    result[child.key] = child;\n  });\n  return result;\n}\n\n/**\n * When you're adding or removing children some may be added or removed in the\n * same render pass. We want to show *both* since we want to simultaneously\n * animate elements in and out. This function takes a previous set of keys\n * and a new set of keys and merges them with its best guess of the correct\n * ordering. In the future we may expose some of the utilities in\n * ReactMultiChild to make this easy, but for now React itself does not\n * directly have this concept of the union of prevChildren and nextChildren\n * so we implement it here.\n *\n * @param {object} prev prev children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @param {object} next next children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @return {object} a key set that contains all keys in `prev` and all keys\n * in `next` in a reasonable order.\n */\nfunction mergeChildMappings(prev, next) {\n  prev = prev || {};\n  next = next || {};\n  function getValueForKey(key) {\n    if (next.hasOwnProperty(key)) {\n      return next[key];\n    }\n    return prev[key];\n  }\n\n  // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n  var nextKeysPending = {};\n  var pendingKeys = [];\n  for (var prevKey in prev) {\n    if (next.hasOwnProperty(prevKey)) {\n      if (pendingKeys.length) {\n        nextKeysPending[prevKey] = pendingKeys;\n        pendingKeys = [];\n      }\n    } else {\n      pendingKeys.push(prevKey);\n    }\n  }\n  var i = void 0;\n  var childMapping = {};\n  for (var nextKey in next) {\n    if (nextKeysPending.hasOwnProperty(nextKey)) {\n      for (i = 0; i < nextKeysPending[nextKey].length; i++) {\n        var pendingNextKey = nextKeysPending[nextKey][i];\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\n      }\n    }\n    childMapping[nextKey] = getValueForKey(nextKey);\n  }\n\n  // Finally, add the keys which didn't appear before any key in `next`\n  for (i = 0; i < pendingKeys.length; i++) {\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n  }\n  return childMapping;\n}","map":{"version":3,"names":["exports","__esModule","getChildMapping","mergeChildMappings","_react","require","children","result","Children","map","child","forEach","key","prev","next","getValueForKey","hasOwnProperty","nextKeysPending","pendingKeys","prevKey","length","push","i","childMapping","nextKey","pendingNextKey"],"sources":["/Users/ayushi/Desktop/repos/nexpert-frontend/node_modules/@bkrem/react-transition-group/utils/ChildMapping.js"],"sourcesContent":["'use strict';\n\nexports.__esModule = true;\nexports.getChildMapping = getChildMapping;\nexports.mergeChildMappings = mergeChildMappings;\n\nvar _react = require('react');\n\n/**\n * Given `this.props.children`, return an object mapping key to child.\n *\n * @param {*} children `this.props.children`\n * @return {object} Mapping of key to child\n */\nfunction getChildMapping(children) {\n  if (!children) {\n    return children;\n  }\n  var result = {};\n  _react.Children.map(children, function (child) {\n    return child;\n  }).forEach(function (child) {\n    result[child.key] = child;\n  });\n  return result;\n}\n\n/**\n * When you're adding or removing children some may be added or removed in the\n * same render pass. We want to show *both* since we want to simultaneously\n * animate elements in and out. This function takes a previous set of keys\n * and a new set of keys and merges them with its best guess of the correct\n * ordering. In the future we may expose some of the utilities in\n * ReactMultiChild to make this easy, but for now React itself does not\n * directly have this concept of the union of prevChildren and nextChildren\n * so we implement it here.\n *\n * @param {object} prev prev children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @param {object} next next children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @return {object} a key set that contains all keys in `prev` and all keys\n * in `next` in a reasonable order.\n */\nfunction mergeChildMappings(prev, next) {\n  prev = prev || {};\n  next = next || {};\n\n  function getValueForKey(key) {\n    if (next.hasOwnProperty(key)) {\n      return next[key];\n    }\n\n    return prev[key];\n  }\n\n  // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n  var nextKeysPending = {};\n\n  var pendingKeys = [];\n  for (var prevKey in prev) {\n    if (next.hasOwnProperty(prevKey)) {\n      if (pendingKeys.length) {\n        nextKeysPending[prevKey] = pendingKeys;\n        pendingKeys = [];\n      }\n    } else {\n      pendingKeys.push(prevKey);\n    }\n  }\n\n  var i = void 0;\n  var childMapping = {};\n  for (var nextKey in next) {\n    if (nextKeysPending.hasOwnProperty(nextKey)) {\n      for (i = 0; i < nextKeysPending[nextKey].length; i++) {\n        var pendingNextKey = nextKeysPending[nextKey][i];\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\n      }\n    }\n    childMapping[nextKey] = getValueForKey(nextKey);\n  }\n\n  // Finally, add the keys which didn't appear before any key in `next`\n  for (i = 0; i < pendingKeys.length; i++) {\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n  }\n\n  return childMapping;\n}"],"mappings":"AAAA,YAAY;;AAEZA,OAAO,CAACC,UAAU,GAAG,IAAI;AACzBD,OAAO,CAACE,eAAe,GAAGA,eAAe;AACzCF,OAAO,CAACG,kBAAkB,GAAGA,kBAAkB;AAE/C,IAAIC,MAAM,GAAGC,OAAO,CAAC,OAAO,CAAC;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA,SAASH,eAAeA,CAACI,QAAQ,EAAE;EACjC,IAAI,CAACA,QAAQ,EAAE;IACb,OAAOA,QAAQ;EACjB;EACA,IAAIC,MAAM,GAAG,CAAC,CAAC;EACfH,MAAM,CAACI,QAAQ,CAACC,GAAG,CAACH,QAAQ,EAAE,UAAUI,KAAK,EAAE;IAC7C,OAAOA,KAAK;EACd,CAAC,CAAC,CAACC,OAAO,CAAC,UAAUD,KAAK,EAAE;IAC1BH,MAAM,CAACG,KAAK,CAACE,GAAG,CAAC,GAAGF,KAAK;EAC3B,CAAC,CAAC;EACF,OAAOH,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASJ,kBAAkBA,CAACU,IAAI,EAAEC,IAAI,EAAE;EACtCD,IAAI,GAAGA,IAAI,IAAI,CAAC,CAAC;EACjBC,IAAI,GAAGA,IAAI,IAAI,CAAC,CAAC;EAEjB,SAASC,cAAcA,CAACH,GAAG,EAAE;IAC3B,IAAIE,IAAI,CAACE,cAAc,CAACJ,GAAG,CAAC,EAAE;MAC5B,OAAOE,IAAI,CAACF,GAAG,CAAC;IAClB;IAEA,OAAOC,IAAI,CAACD,GAAG,CAAC;EAClB;;EAEA;EACA;EACA,IAAIK,eAAe,GAAG,CAAC,CAAC;EAExB,IAAIC,WAAW,GAAG,EAAE;EACpB,KAAK,IAAIC,OAAO,IAAIN,IAAI,EAAE;IACxB,IAAIC,IAAI,CAACE,cAAc,CAACG,OAAO,CAAC,EAAE;MAChC,IAAID,WAAW,CAACE,MAAM,EAAE;QACtBH,eAAe,CAACE,OAAO,CAAC,GAAGD,WAAW;QACtCA,WAAW,GAAG,EAAE;MAClB;IACF,CAAC,MAAM;MACLA,WAAW,CAACG,IAAI,CAACF,OAAO,CAAC;IAC3B;EACF;EAEA,IAAIG,CAAC,GAAG,KAAK,CAAC;EACd,IAAIC,YAAY,GAAG,CAAC,CAAC;EACrB,KAAK,IAAIC,OAAO,IAAIV,IAAI,EAAE;IACxB,IAAIG,eAAe,CAACD,cAAc,CAACQ,OAAO,CAAC,EAAE;MAC3C,KAAKF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,eAAe,CAACO,OAAO,CAAC,CAACJ,MAAM,EAAEE,CAAC,EAAE,EAAE;QACpD,IAAIG,cAAc,GAAGR,eAAe,CAACO,OAAO,CAAC,CAACF,CAAC,CAAC;QAChDC,YAAY,CAACN,eAAe,CAACO,OAAO,CAAC,CAACF,CAAC,CAAC,CAAC,GAAGP,cAAc,CAACU,cAAc,CAAC;MAC5E;IACF;IACAF,YAAY,CAACC,OAAO,CAAC,GAAGT,cAAc,CAACS,OAAO,CAAC;EACjD;;EAEA;EACA,KAAKF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,WAAW,CAACE,MAAM,EAAEE,CAAC,EAAE,EAAE;IACvCC,YAAY,CAACL,WAAW,CAACI,CAAC,CAAC,CAAC,GAAGP,cAAc,CAACG,WAAW,CAACI,CAAC,CAAC,CAAC;EAC/D;EAEA,OAAOC,YAAY;AACrB"},"metadata":{},"sourceType":"script","externalDependencies":[]}